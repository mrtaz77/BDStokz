/*
 Navicat Premium Data Transfer

 Source Server         : PROJECT_DB
 Source Server Type    : Oracle
 Source Server Version : 190000 (Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production)
 Source Schema         : C##STOCKDB

 Target Server Type    : Oracle
 Target Server Version : 190000 (Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production)
 File Encoding         : 65001

 Date: 06/11/2023 17:55:53
*/


-- ----------------------------
-- Table structure for ACTIVITY
-- ----------------------------
DROP TABLE "C##STOCKDB"."ACTIVITY";
CREATE TABLE "C##STOCKDB"."ACTIVITY" (
  "ACTIVITY_ID" NUMBER VISIBLE DEFAULT "C##STOCKDB"."ACTIVITY_ID_SEQ"."NEXTVAL" NOT NULL,
  "CORP_ID" NUMBER VISIBLE NOT NULL,
  "DATE" DATE VISIBLE NOT NULL,
  "START_TIME" TIMESTAMP(6) VISIBLE NOT NULL,
  "DURATION(min)" NUMBER(10,0) VISIBLE NOT NULL,
  "TYPE" VARCHAR2(50 BYTE) VISIBLE NOT NULL,
  "VENUE" VARCHAR2(100 BYTE) VISIBLE,
  "FEE" NUMBER(10,2) VISIBLE,
  "DESCRIPTION" VARCHAR2(200 BYTE) VISIBLE
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for ADMIN
-- ----------------------------
DROP TABLE "C##STOCKDB"."ADMIN";
CREATE TABLE "C##STOCKDB"."ADMIN" (
  "ADMIN_ID" NUMBER VISIBLE NOT NULL,
  "ADDER_ID" NUMBER VISIBLE,
  "EMPLOYEE_ID" NUMBER VISIBLE NOT NULL,
  "FUNDS" NUMBER(10,2) VISIBLE,
  "IS_DELETED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for ADMIN_LOG
-- ----------------------------
DROP TABLE "C##STOCKDB"."ADMIN_LOG";
CREATE TABLE "C##STOCKDB"."ADMIN_LOG" (
  "ADMIN_LOG_ID" NUMBER VISIBLE DEFAULT "C##STOCKDB"."ADMINLOG_ID_SEQ"."NEXTVAL" NOT NULL,
  "EVENT_TYPE" VARCHAR2(50 BYTE) VISIBLE,
  "DESCRIPTION" VARCHAR2(255 BYTE) VISIBLE,
  "EVENT_TIME" DATE VISIBLE DEFAULT SYSDATE
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for BACKUP STOCK
-- ----------------------------
DROP TABLE "C##STOCKDB"."BACKUP STOCK";
CREATE TABLE "C##STOCKDB"."BACKUP STOCK" (
  "SYMBOL" VARCHAR2(10 BYTE) VISIBLE NOT NULL,
  "AVAILABLE_LOTS" NUMBER VISIBLE,
  "BLOCKED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for BROKER
-- ----------------------------
DROP TABLE "C##STOCKDB"."BROKER";
CREATE TABLE "C##STOCKDB"."BROKER" (
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "LICENSE_NO" VARCHAR2(20 BYTE) VISIBLE NOT NULL,
  "COMMISSION_PCT" NUMBER(5,2) VISIBLE,
  "EXPERTISE" VARCHAR2(100 BYTE) VISIBLE,
  "IS_DELETED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for CORPORATION
-- ----------------------------
DROP TABLE "C##STOCKDB"."CORPORATION";
CREATE TABLE "C##STOCKDB"."CORPORATION" (
  "CORP_ID" NUMBER VISIBLE NOT NULL,
  "CORP_REG_NO" NUMBER VISIBLE NOT NULL,
  "SECTOR" VARCHAR2(30 BYTE) VISIBLE NOT NULL,
  "IS_DELETED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for CUSTOMER
-- ----------------------------
DROP TABLE "C##STOCKDB"."CUSTOMER";
CREATE TABLE "C##STOCKDB"."CUSTOMER" (
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "ACCOUNT_NO" VARCHAR2(20 BYTE) VISIBLE NOT NULL,
  "REFERER_ID" NUMBER VISIBLE,
  "REFER_COUNT" NUMBER VISIBLE DEFAULT 0,
  "BROKER_ID" NUMBER VISIBLE,
  "IS_DELETED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for EMPLOYEE
-- ----------------------------
DROP TABLE "C##STOCKDB"."EMPLOYEE";
CREATE TABLE "C##STOCKDB"."EMPLOYEE" (
  "EMPLOYEE_ID" NUMBER VISIBLE DEFAULT "C##STOCKDB"."EMPLOYEE_ID_SEQ"."NEXTVAL" NOT NULL,
  "FIRST_NAME" VARCHAR2(50 BYTE) VISIBLE NOT NULL,
  "LAST_NAME" VARCHAR2(50 BYTE) VISIBLE NOT NULL,
  "EMAIL" VARCHAR2(255 BYTE) VISIBLE NOT NULL,
  "SEX" CHAR(1 BYTE) VISIBLE,
  "NID" VARCHAR2(20 BYTE) VISIBLE,
  "DESIGNATION" VARCHAR2(100 BYTE) VISIBLE,
  "ADDRESS" VARCHAR2(100 BYTE) VISIBLE,
  "ZIP_CODE" VARCHAR2(10 BYTE) VISIBLE,
  "SALARY" NUMBER(10,2) VISIBLE,
  "HIRE_DATE" DATE VISIBLE,
  "DOB" DATE VISIBLE,
  "MANAGER_ID" NUMBER VISIBLE,
  "IS_DELETED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for EMP_CONTACT
-- ----------------------------
DROP TABLE "C##STOCKDB"."EMP_CONTACT";
CREATE TABLE "C##STOCKDB"."EMP_CONTACT" (
  "EMPLOYEE_ID" NUMBER VISIBLE NOT NULL,
  "CONTACT" VARCHAR2(20 BYTE) VISIBLE NOT NULL
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for ORDER
-- ----------------------------
DROP TABLE "C##STOCKDB"."ORDER";
CREATE TABLE "C##STOCKDB"."ORDER" (
  "ORDER_ID" NUMBER VISIBLE DEFAULT "C##STOCKDB"."ORDER_ID_SEQ"."NEXTVAL" NOT NULL,
  "SYMBOL" VARCHAR2(10 BYTE) VISIBLE NOT NULL,
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "STATUS" VARCHAR2(20 BYTE) VISIBLE DEFAULT 'PENDING',
  "TYPE" VARCHAR2(10 BYTE) VISIBLE,
  "LATEST_PRICE" NUMBER(10,2) VISIBLE DEFAULT 0,
  "LATEST_QUANTITY" NUMBER VISIBLE DEFAULT 0,
  "LATEST_UPDATE_TIME" TIMESTAMP(6) VISIBLE DEFAULT (SYSDATE),
  "TRANSACTION_FEE" NUMBER(10,2) VISIBLE DEFAULT 0,
  "TRANSACTION_TIME" TIMESTAMP(6) VISIBLE DEFAULT (NULL),
  "STOP_PRICE" NUMBER(10,2) VISIBLE
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for OWNS
-- ----------------------------
DROP TABLE "C##STOCKDB"."OWNS";
CREATE TABLE "C##STOCKDB"."OWNS" (
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "SYMBOL" VARCHAR2(10 BYTE) VISIBLE NOT NULL,
  "QUANTITY" NUMBER VISIBLE DEFAULT (0)
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for PARTICIPATION
-- ----------------------------
DROP TABLE "C##STOCKDB"."PARTICIPATION";
CREATE TABLE "C##STOCKDB"."PARTICIPATION" (
  "ACTIVITY_ID" NUMBER VISIBLE NOT NULL,
  "USER_ID" NUMBER VISIBLE NOT NULL
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for PORTFOLIO
-- ----------------------------
DROP TABLE "C##STOCKDB"."PORTFOLIO";
CREATE TABLE "C##STOCKDB"."PORTFOLIO" (
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "SECTOR" VARCHAR2(30 BYTE) VISIBLE NOT NULL,
  "BUY_AMOUNT" NUMBER(10,2) VISIBLE DEFAULT 0,
  "SELL_AMOUNT" NUMBER(10,2) VISIBLE DEFAULT 0
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for STOCK
-- ----------------------------
DROP TABLE "C##STOCKDB"."STOCK";
CREATE TABLE "C##STOCKDB"."STOCK" (
  "SYMBOL" VARCHAR2(10 BYTE) VISIBLE NOT NULL,
  "CORP_ID" NUMBER VISIBLE,
  "UPDATE_TIME" TIMESTAMP(6) VISIBLE DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "VALUE" NUMBER(10,2) VISIBLE NOT NULL,
  "PRICE" NUMBER(10,2) VISIBLE NOT NULL,
  "LTP" NUMBER(10,2) VISIBLE NOT NULL,
  "BLOCKED" CHAR(1 BYTE) VISIBLE,
  "AVAILABLE_LOTS" NUMBER(10,2) VISIBLE DEFAULT 0,
  "LOT" NUMBER(10,2) VISIBLE DEFAULT 0
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for USER
-- ----------------------------
DROP TABLE "C##STOCKDB"."USER";
CREATE TABLE "C##STOCKDB"."USER" (
  "USER_ID" NUMBER VISIBLE DEFAULT "C##STOCKDB"."USER_ID_SEQ"."NEXTVAL" NOT NULL,
  "NAME" VARCHAR2(100 BYTE) VISIBLE NOT NULL,
  "PWD" VARCHAR2(128 BYTE) VISIBLE NOT NULL,
  "EMAIL" VARCHAR2(255 BYTE) VISIBLE NOT NULL,
  "TYPE" VARCHAR2(30 BYTE) VISIBLE NOT NULL,
  "STREET_NO" VARCHAR2(10 BYTE) VISIBLE,
  "STREET_NAME" VARCHAR2(100 BYTE) VISIBLE,
  "CITY" VARCHAR2(50 BYTE) VISIBLE NOT NULL,
  "COUNTRY" VARCHAR2(50 BYTE) VISIBLE NOT NULL,
  "ZIP" VARCHAR2(12 BYTE) VISIBLE NOT NULL,
  "REG_DATE" DATE VISIBLE NOT NULL,
  "IS_DELETED" VARCHAR2(2 BYTE) VISIBLE DEFAULT 'F'
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for USER_CONTACT
-- ----------------------------
DROP TABLE "C##STOCKDB"."USER_CONTACT";
CREATE TABLE "C##STOCKDB"."USER_CONTACT" (
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "CONTACT" VARCHAR2(20 BYTE) VISIBLE NOT NULL
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Table structure for USER_LOG
-- ----------------------------
DROP TABLE "C##STOCKDB"."USER_LOG";
CREATE TABLE "C##STOCKDB"."USER_LOG" (
  "USER_LOG_ID" NUMBER VISIBLE DEFAULT "C##STOCKDB"."USERLOG_ID_SEQ"."NEXTVAL" NOT NULL,
  "USER_ID" NUMBER VISIBLE NOT NULL,
  "EVENT_TYPE" VARCHAR2(50 BYTE) VISIBLE,
  "DESCRIPTION" VARCHAR2(255 BYTE) VISIBLE,
  "EVENT_TIME" DATE VISIBLE DEFAULT SYSDATE
)
LOGGING
NOCOMPRESS
PCTFREE 10
INITRANS 1
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- View structure for DAILY_PROFIT_VIEW
-- ----------------------------
CREATE OR REPLACE VIEW "C##STOCKDB"."DAILY_PROFIT_VIEW" AS SELECT
	C.SECTOR,
	SUM( NVL( D.TRANSACTION_FEE, 0 ) ) PROFIT 
FROM
	( SELECT DISTINCT SECTOR FROM CORPORATION ) C LEFT OUTER
	JOIN (
	SELECT
		SECTOR_OF_STOCK ( O1.SYMBOL ) SECTOR,
		O1.TRANSACTION_FEE,
		TRUNC( O1.TRANSACTION_TIME ) 
	FROM
		"ORDER" O1 
	WHERE
		O1.STATUS = 'SUCCESS' 
		AND TRUNC( O1.TRANSACTION_TIME ) >= ALL (
		SELECT
			TRUNC( O2.TRANSACTION_TIME ) 
		FROM
			"ORDER" O2 
		WHERE
			SECTOR_OF_STOCK ( O2.SYMBOL ) = SECTOR_OF_STOCK ( O1.SYMBOL ) 
			AND O2.STATUS = 'SUCCESS' 
		) 
	) D ON C.SECTOR = D.SECTOR 
GROUP BY
	C.SECTOR 
ORDER BY
	C.SECTOR;

-- ----------------------------
-- Function structure for AVG_PRICE_ACROSS_YEAR
-- ----------------------------
CREATE OR REPLACE
PROCEDURE "C##STOCKDB"."AVG_PRICE_ACROSS_YEAR" AS
BEGIN
  FOR R IN (
    SELECT
      TRUNC(TRANSACTION_TIME) DAT,
      ROUND( AVG( LATEST_PRICE ), 4 ) AVG_PRICE 
    FROM
      "ORDER" 
    WHERE
      STATUS = 'SUCCESS' 
      AND TRUNC( SYSDATE ) - TRUNC( TRANSACTION_TIME ) <= 365
    GROUP BY
      TRUNC(TRANSACTION_TIME)
    ORDER BY
      TRUNC(TRANSACTION_TIME) DESC
  )
  LOOP 
    -- Loop to fill in missing dates with zero values
    WHILE CURR_DATE > R.DAT
    LOOP 
      JSON_DATA := JSON_DATA || '{"x":'|| TIME_TO_EPOCH(trunc(CURR_DATE))*1000 || ',"y":'||0||'}';
      IF CURR_DATE <> END_DATE THEN 
        JSON_DATA := JSON_DATA ||',';
      END IF;
      CURR_DATE := CURR_DATE - 1;
    END LOOP;
    
    -- Append JSON data for the current date
    JSON_DATA := JSON_DATA || '{"x":'|| TIME_TO_EPOCH(trunc(R.DAT))*1000 || ',"y":'||R.AVG_PRICE||'}';
    
    -- Append a comma if not the last date
    IF CURR_DATE <> END_DATE THEN 
      JSON_DATA := JSON_DATA ||',';
    END IF;
    
    CURR_DATE := CURR_DATE - 1;
  END LOOP;
  
  -- Loop to fill in remaining missing dates with zero values
  WHILE CURR_DATE >= END_DATE
  LOOP 
    JSON_DATA := JSON_DATA ||'{"x":'|| TIME_TO_EPOCH(trunc(CURR_DATE))*1000 || ',"y":'||0||'}';
    IF CURR_DATE <> END_DATE THEN 
      JSON_DATA := JSON_DATA || ',';
    END IF;
    CURR_DATE := CURR_DATE - 1;
  END LOOP;
  
  -- Complete the JSON array
  JSON_DATA := JSON_DATA || ']';
  
  -- Assign the JSON data to the output CLOB
  LISTAVP := JSON_DATA;
END;
/

-- ----------------------------
-- Function structure for BROKER_COMMISSION_PCT
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."BROKER_COMMISSION_PCT" AS
BEGIN 
SELECT COUNT(USER_ID) INTO CHK_BID FROM BROKER WHERE USER_ID = BID AND IS_DELETED = 'F';

IF CHK_BID = 0 THEN 
	RETURN 0;
ELSE 
SELECT LEAST(0.01 + ROUND(NVL(SUM(LATEST_QUANTITY),0)/100000,0)*0.01,4) INTO COM_PCT
FROM CUSTOMER LEFT OUTER JOIN "ORDER" ON "ORDER".USER_ID = CUSTOMER.USER_ID
WHERE STATUS = 'SUCCESS' AND BROKER_ID = BID AND CUSTOMER.IS_DELETED = 'F';
END  IF;
RETURN COM_PCT;
EXCEPTION
WHEN OTHERS THEN 
	RETURN 0;
END;
/

-- ----------------------------
-- Function structure for CHK_CREDS_NAME
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."CHK_CREDS_NAME" AS
BEGIN
	SELECT COUNT(USER_ID) INTO CHK_USER FROM "USER" WHERE NAME = USER_NAME AND IS_DELETED = 'F';
	
	IF CHK_USER = 0 THEN 
		RETURN -404;
	ELSE 
			SELECT PWD INTO CHK_PWD FROM "USER" WHERE NAME = USER_NAME AND IS_DELETED = 'F';
			
			IF CHK_PWD = PWD_HASH(USER_PWD) THEN 
				RETURN 1337;
			ELSE
				RETURN -404;
			END IF;
	END IF;
EXCEPTION
		WHEN NO_DATA_FOUND THEN 
			RETURN -1;
END;
/

-- ----------------------------
-- Function structure for CLOSE
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."CLOSE" AS
BEGIN
		CL := 0.0000;
	SELECT
		O1.LATEST_PRICE INTO CL 
	FROM
		"ORDER" O1 
	WHERE
		O1.SYMBOL = SYM 
		AND O1.STATUS = 'SUCCESS' 
		AND TRUNC( O1.TRANSACTION_TIME ) >= ALL ( SELECT TRUNC( O2.TRANSACTION_TIME ) FROM "ORDER" O2 WHERE O2.SYMBOL = O1.SYMBOL AND O2.STATUS = 'SUCCESS' ) 
	ORDER BY
		O1.TRANSACTION_TIME DESC FETCH FIRST 1 ROW ONLY;
	RETURN CL;
	EXCEPTION 
		WHEN OTHERS THEN
		RETURN 0;
END;
/

-- ----------------------------
-- Function structure for DAILY_PROFIT
-- ----------------------------
CREATE OR REPLACE
PROCEDURE "C##STOCKDB"."DAILY_PROFIT" AS
BEGIN
  -- Open the cursor and fetch data into the collection
  OPEN c_sector_profits;
  FETCH c_sector_profits BULK COLLECT INTO v_sector_profits;
  CLOSE c_sector_profits;

  FOR i IN v_sector_profits.FIRST .. v_sector_profits.LAST LOOP
    -- Append each record as a JSON object
    v_json := v_json || ', {"sector": "' || v_sector_profits(i).sector ||
                           '", "profit": ' || v_sector_profits(i).profit || '}';
  END LOOP;

  -- Wrap the JSON object
  v_json := '{"data": [' || SUBSTR(v_json, 2) || ']}';

  -- Set the output parameter
  profits := v_json;
END;
/

-- ----------------------------
-- Function structure for DURATION_FORMAT
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."DURATION_FORMAT" AS
BEGIN
	TIME := ''; 
	H := TRUNC(T/60);
	M := (T-TRUNC(T/60)*60);
	IF H > 0 THEN 
		TIME := TIME || H || ' hr ';
	END IF;
	IF M > 0 THEN 
		TIME := TIME || M || ' min';
	END IF;
	RETURN TIME;
EXCEPTION
	WHEN OTHERS THEN 
		RETURN '';
END;
/

-- ----------------------------
-- Function structure for FORMAT_TIMESTAMP_ORDER
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."FORMAT_TIMESTAMP_ORDER" AS
BEGIN
    -- Format the timestamp as a human-readable string
    SELECT TO_CHAR(inputTimestamp, 'DD-MON-YYYY HH:MI:SS AM', 'NLS_DATE_LANGUAGE=ENGLISH')
    INTO formattedTimestamp
    FROM DUAL;

    RETURN formattedTimestamp;
EXCEPTION 
	WHEN OTHERS THEN 
		RETURN '';
END;
/

-- ----------------------------
-- Function structure for HIGH
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."HIGH" AS
BEGIN
	HIGH := 0.0000;
	SELECT MAX(O1.LATEST_PRICE) INTO HIGH
	FROM "ORDER" O1 
	WHERE O1.SYMBOL = SYM AND O1.STATUS = 'SUCCESS' AND
	TRUNC(O1.TRANSACTION_TIME) >= ALL(SELECT TRUNC(O2.TRANSACTION_TIME) FROM "ORDER" O2 WHERE O2.SYMBOL = SYM AND O2.STATUS = 'SUCCESS')
	GROUP BY 
	SYMBOL,TRUNC(O1.TRANSACTION_TIME);
	RETURN HIGH;
EXCEPTION
	WHEN OTHERS THEN 
		RETURN 0;
END;
/

-- ----------------------------
-- Function structure for IS_PREM
-- ----------------------------
CREATE OR REPLACE
PROCEDURE "C##STOCKDB"."IS_PREM" AS
BEGIN
	FLAG := 'N';
	
	SELECT COUNT(USER_ID) INTO CHK_FLAG FROM "USER" WHERE USER_ID = USID AND "USER".IS_DELETED = 'F';
	
	IF CHK_FLAG = 0 THEN
		FLAG := 'N';
	ELSE 
	SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = USID AND "USER".IS_DELETED = 'F';
	IF TYP = 'Admin' THEN
		FLAG := 'T';
	ELSIF TYP = 'Customer' THEN
		SELECT REFER_COUNT INTO RF_COUNT FROM CUSTOMER WHERE USER_ID = USID;
		IF RF_COUNT >= 4 THEN 
			FLAG := 'T';
		ELSE 
			FLAG := 'F';
		END IF;
	ELSIF TYP = 'Broker' THEN 
		FLAG := 'F';
	ELSIF TYP = 'Corp' THEN 
		FLAG := 'F';
	ELSE 
		FLAG := 'N';
	END IF;
END IF;
EXCEPTION
	WHEN OTHERS THEN 
		FLAG := 'N';
END;
/

-- ----------------------------
-- Function structure for LOW
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."LOW" AS
BEGIN
	LOW := 0.0000;
	SELECT MIN(O1.LATEST_PRICE) INTO LOW
	FROM "ORDER" O1 
	WHERE O1.SYMBOL = SYM AND O1.STATUS = 'SUCCESS' AND 
	TRUNC(O1.TRANSACTION_TIME) >= ALL(SELECT TRUNC(O2.TRANSACTION_TIME) FROM "ORDER" O2 WHERE O2.SYMBOL = SYM AND O2.STATUS = 'SUCCESS')
	GROUP BY 
	SYMBOL,TRUNC(O1.TRANSACTION_TIME);
	RETURN LOW;
EXCEPTION
	WHEN OTHERS THEN 
		RETURN 0;
END;
/

-- ----------------------------
-- Function structure for OPEN
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."OPEN" AS
BEGIN
		OP := 0.0000;
	SELECT
		O1.LATEST_PRICE INTO OP 
	FROM
		"ORDER" O1 
	WHERE
		O1.SYMBOL = SYM 
		AND O1.STATUS = 'SUCCESS' 
		AND TRUNC( O1.TRANSACTION_TIME ) = (
		SELECT
			MAX( TRUNC( O2.TRANSACTION_TIME ) ) 
		FROM
			"ORDER" O2 
		WHERE
			O2.SYMBOL = O1.SYMBOL 
			AND O2.STATUS = 'SUCCESS' 
		) 
	ORDER BY
		O1.TRANSACTION_TIME FETCH FIRST 1 ROW ONLY;
	RETURN OP;
	EXCEPTION 
		WHEN OTHERS THEN
		RETURN 0;
END;
/

-- ----------------------------
-- Function structure for PWD_HASH
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."PWD_HASH" AS
BEGIN
  encoded_string := UTL_RAW.CAST_TO_VARCHAR2(UTL_ENCODE.BASE64_ENCODE(UTL_RAW.CAST_TO_RAW(input_string)));

  SELECT STANDARD_HASH(encoded_string,'SHA512') INTO hash_raw FROM DUAL;

  hash_output := RAWTOHEX(hash_raw);

  RETURN hash_output;
EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL;
END;
/

-- ----------------------------
-- Function structure for SECTOR_OF_STOCK
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."SECTOR_OF_STOCK" AS
BEGIN
SELECT SECTOR INTO SEC FROM CORPORATION NATURAL JOIN STOCK WHERE SYMBOL = SYM AND BLOCKED = 'F';
RETURN SEC;
EXCEPTION
	WHEN OTHERS THEN RETURN '';
END;
/

-- ----------------------------
-- Function structure for SELL_ORDER_SUCCESS
-- ----------------------------
CREATE OR REPLACE
PROCEDURE "C##STOCKDB"."SELL_ORDER_SUCCESS" AS
BEGIN
    SELECT SYMBOL INTO ORDER_SYM FROM "ORDER" WHERE ORDER_ID = OID;
    SELECT USER_ID INTO SELLER_ID FROM "ORDER" WHERE ORDER_ID = OID;
    SELECT LATEST_PRICE INTO LATEST_PRICE FROM "ORDER" WHERE ORDER_ID = OID;
    SELECT LATEST_QUANTITY INTO LATEST_QUANTITY FROM "ORDER" WHERE ORDER_ID = OID;
		SELECT NAME INTO BUYER_NAME FROM "USER" WHERE USER_ID = BUYER_ID;
		SELECT NAME INTO SELLER_NAME FROM "USER" WHERE USER_ID = SELLER_ID;
		
    IF BUYER_ID = SELLER_ID THEN 
        RAISE_APPLICATION_ERROR(-20008,'Buyer and seller must be different');
    END IF;


    SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = BUYER_ID;
    IF TYP = 'Customer' THEN 
        SELECT COUNT(*) INTO COUNT_SYM 
        FROM OWNS WHERE SYMBOL = ORDER_SYM AND USER_ID = BUYER_ID;
                    
        IF COUNT_SYM = 0 THEN 
            INSERT INTO OWNS VALUES(BUYER_ID,ORDER_SYM,LATEST_QUANTITY);
        ELSE 
            UPDATE OWNS
            SET QUANTITY = QUANTITY + LATEST_QUANTITY
            WHERE USER_ID = BUYER_ID AND SYMBOL = ORDER_SYM;
        END IF;

        SELECT COUNT(*) INTO FLAG 
        FROM PORTFOLIO WHERE SECTOR = SECTOR_OF_STOCK(ORDER_SYM) AND USER_ID = BUYER_ID;
        
        IF FLAG = 0 THEN
            INSERT INTO PORTFOLIO VALUES (BUYER_ID,SECTOR_OF_STOCK(ORDER_SYM),LATEST_PRICE*LATEST_QUANTITY,0);
        ELSE 
            UPDATE PORTFOLIO
            SET BUY_AMOUNT = BUY_AMOUNT + LATEST_PRICE*LATEST_QUANTITY
            WHERE USER_ID = BUYER_ID AND SECTOR = SECTOR_OF_STOCK(ORDER_SYM);
        END IF;
    ELSIF TYP = 'Admin' THEN 
        FUND := 0;
        SELECT FUNDS INTO FUND FROM ADMIN WHERE ADMIN_ID = BUYER_ID;

        IF FUND < LATEST_PRICE*LATEST_QUANTITY THEN 
            RAISE_APPLICATION_ERROR(-20007,'Insufficient funds');
        END IF;

        UPDATE ADMIN
        SET FUNDS = FUNDS - LATEST_PRICE*LATEST_QUANTITY
        WHERE ADMIN_ID = BUYER_ID;


		SELECT COUNT(*) INTO COUNT_SYM 
        FROM "BACKUP STOCK"
        WHERE SYMBOL = ORDER_SYM;
				
		SELECT LOT INTO NUM_LOT FROM STOCK WHERE SYMBOL = ORDER_SYM ;

        IF COUNT_SYM = 0 THEN
            INSERT INTO "BACKUP STOCK" VALUES (ORDER_SYM,LATEST_QUANTITY/NUM_LOT,'F');
        ELSE 
            UPDATE "BACKUP STOCK" 
            SET AVAILABLE_LOTS = AVAILABLE_LOTS + (LATEST_QUANTITY/NUM_LOT)
            WHERE SYMBOL = ORDER_SYM;
        END IF;
    END IF;
		DBMS_OUTPUT.PUT_LINE('BUYER INFO SET');

    UPDATE "ORDER"
    SET STATUS = 'SUCCESS'
    WHERE ORDER_ID = OID;
		DBMS_OUTPUT.PUT_LINE('SELLER INFO SET');
		
		SELECT LOT INTO NUM_LOT FROM STOCK WHERE SYMBOL = ORDER_SYM ;
		NUM_LOT_SOLD := ROUND(LATEST_QUANTITY/NUM_LOT,2);
		
		
		INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (BUYER_ID,'PURCHASE','You purchased '||NUM_LOT_SOLD||' number of lots of '||ORDER_SYM||' at price '||LATEST_PRICE||' from '||SELLER_NAME);
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('PURCHASE',BUYER_NAME||' purchased '||NUM_LOT_SOLD||' number of lots of '||ORDER_SYM||' at price '||LATEST_PRICE||' from '||SELLER_NAME);
		INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (SELLER_ID,'PURCHASE',BUYER_NAME||' purchased '||NUM_LOT_SOLD||' number of lots of '||ORDER_SYM||' at price '||LATEST_PRICE||' from you');
		
EXCEPTION
WHEN OTHERS THEN 
	DBMS_OUTPUT.PUT_LINE('SOME ERROR OCCURED');
	ROLLBACK;
END;
/

-- ----------------------------
-- Function structure for TIME_FORMAT
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."TIME_FORMAT" AS
BEGIN
    IF EXTRACT(HOUR FROM ts) >= 9 THEN
        formatted_time := TO_CHAR(ts, 'HH:MI AM');
    ELSE
        formatted_time := TO_CHAR(ts, 'HH:MI PM');
    END IF;
    
    RETURN formatted_time;
END;
/

-- ----------------------------
-- Function structure for TIME_TO_EPOCH
-- ----------------------------
CREATE OR REPLACE
FUNCTION "C##STOCKDB"."TIME_TO_EPOCH" AS
BEGIN 
	EP := 0;
	SELECT
		ROUND( ( CAST( SYS_EXTRACT_UTC( TM ) AS DATE ) - TO_DATE( '1970-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS' ) ) * 86400, 4 ) INTO EP 
	FROM
		DUAL;
	ANS := EP;
		RETURN ANS;
EXCEPTION
	WHEN OTHERS THEN 
		RETURN '';
END;
/

-- ----------------------------
-- Sequence structure for ACTIVITY_ID_SEQ
-- ----------------------------
DROP SEQUENCE "C##STOCKDB"."ACTIVITY_ID_SEQ";
CREATE SEQUENCE "C##STOCKDB"."ACTIVITY_ID_SEQ" MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 10 NOCACHE;

-- ----------------------------
-- Sequence structure for ADMINLOG_ID_SEQ
-- ----------------------------
DROP SEQUENCE "C##STOCKDB"."ADMINLOG_ID_SEQ";
CREATE SEQUENCE "C##STOCKDB"."ADMINLOG_ID_SEQ" MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 10 NOCACHE;

-- ----------------------------
-- Sequence structure for EMPLOYEE_ID_SEQ
-- ----------------------------
DROP SEQUENCE "C##STOCKDB"."EMPLOYEE_ID_SEQ";
CREATE SEQUENCE "C##STOCKDB"."EMPLOYEE_ID_SEQ" MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 10 NOCACHE;

-- ----------------------------
-- Sequence structure for ORDER_ID_SEQ
-- ----------------------------
DROP SEQUENCE "C##STOCKDB"."ORDER_ID_SEQ";
CREATE SEQUENCE "C##STOCKDB"."ORDER_ID_SEQ" MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 NOCACHE;

-- ----------------------------
-- Sequence structure for USERLOG_ID_SEQ
-- ----------------------------
DROP SEQUENCE "C##STOCKDB"."USERLOG_ID_SEQ";
CREATE SEQUENCE "C##STOCKDB"."USERLOG_ID_SEQ" MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 10 NOCACHE;

-- ----------------------------
-- Sequence structure for USER_ID_SEQ
-- ----------------------------
DROP SEQUENCE "C##STOCKDB"."USER_ID_SEQ";
CREATE SEQUENCE "C##STOCKDB"."USER_ID_SEQ" MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 10 NOCACHE;

-- ----------------------------
-- Primary Key structure for table ACTIVITY
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "PK_ACTIVITY" PRIMARY KEY ("ACTIVITY_ID");

-- ----------------------------
-- Checks structure for table ACTIVITY
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "CHK_ACTIVITY_DATE" CHECK ("DATE" > TO_DATE('1-1-2015','DD-MM-YYYY')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "SYS_C009093" CHECK ("ACTIVITY_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "SYS_C009094" CHECK ("CORP_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "SYS_C009095" CHECK ("DATE" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "SYS_C009096" CHECK ("START_TIME" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "SYS_C009097" CHECK ("DURATION(min)" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "SYS_C009098" CHECK ("TYPE" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table ACTIVITY
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."DELETE_PARTICIPATION_OF_UPCOMING_ACTIVITY" AFTER DELETE ON "C##STOCKDB"."ACTIVITY" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	DELETE FROM PARTICIPATION 
	WHERE ACTIVITY_ID = :OLD.ACTIVITY_ID;
END;
/

-- ----------------------------
-- Primary Key structure for table ADMIN
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "PK_ADMIN" PRIMARY KEY ("ADMIN_ID");

-- ----------------------------
-- Checks structure for table ADMIN
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "ADMIN_DELETED_CHECK" CHECK (IS_DELETED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "SYS_C009058" CHECK ("ADMIN_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "SYS_C009059" CHECK ("EMPLOYEE_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table ADMIN
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."ADMIN_FUNDS_UPDATE" AFTER UPDATE OF "FUNDS" ON "C##STOCKDB"."ADMIN" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.ADMIN_ID,'FUNDS UPDATE','Your funds changed from '||:OLD.FUNDS||' -> '||:NEW.FUNDS);
INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('FUNDS UPDATE',:NEW.ADMIN_ID||' : '||:OLD.FUNDS||' -> '||:NEW.FUNDS);
END;
/

-- ----------------------------
-- Primary Key structure for table ADMIN_LOG
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ADMIN_LOG" ADD CONSTRAINT "PK_ADMIN_LOG" PRIMARY KEY ("ADMIN_LOG_ID");

-- ----------------------------
-- Checks structure for table ADMIN_LOG
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ADMIN_LOG" ADD CONSTRAINT "SYS_C009322" CHECK ("ADMIN_LOG_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Primary Key structure for table BACKUP STOCK
-- ----------------------------
ALTER TABLE "C##STOCKDB"."BACKUP STOCK" ADD CONSTRAINT "PK_BACKUP_STOCK" PRIMARY KEY ("SYMBOL");

-- ----------------------------
-- Checks structure for table BACKUP STOCK
-- ----------------------------
ALTER TABLE "C##STOCKDB"."BACKUP STOCK" ADD CONSTRAINT "BS_BLOCKED_CHECK" CHECK (BLOCKED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."BACKUP STOCK" ADD CONSTRAINT "SYS_C009064" CHECK ("SYMBOL" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table BACKUP STOCK
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."BACKUP_LOG" AFTER INSERT OR UPDATE OF "AVAILABLE_LOTS" ON "C##STOCKDB"."BACKUP STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
IF INSERTING THEN 
INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('BACKUP STOCK PURCHASE',:NEW.AVAILABLE_LOTS||' lots of stock '||:new.SYMBOL||' purchased');
ELSIF UPDATING('AVAILABLE_LOTS') THEN 
INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('BACKUP STOCK UPDATE',:OLD.AVAILABLE_LOTS||' -> '||:new.AVAILABLE_LOTS||' for '||:new.SYMBOL);
END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table BROKER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."BROKER" ADD CONSTRAINT "PK_BROKER" PRIMARY KEY ("USER_ID");

-- ----------------------------
-- Uniques structure for table BROKER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."BROKER" ADD CONSTRAINT "UK_LICENSE" UNIQUE ("LICENSE_NO") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Checks structure for table BROKER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."BROKER" ADD CONSTRAINT "BROKER_DELETED_CHECK" CHECK (IS_DELETED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."BROKER" ADD CONSTRAINT "SYS_C008990" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."BROKER" ADD CONSTRAINT "SYS_C008991" CHECK ("LICENSE_NO" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table BROKER
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."BROKER_DETAILS_UPDATE_LOG" AFTER UPDATE OF "COMMISSION_PCT", "EXPERTISE", "LICENSE_NO" ON "C##STOCKDB"."BROKER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF UPDATING('LICENSE_NO') THEN 
		INSERT INTO user_log (user_id, event_type, description) 
		VALUES (:NEW.user_id,'UPDATE LICENSE_NO','Your license_no has been changed to '||:NEW.LICENSE_NO || ' successfully');
		INSERT INTO admin_log (event_type, DESCRIPTION) 
		VALUES ('UPDATE LICENSE_NO','License_no of '||:NEW.USER_ID || ' changed from '||:OLD.LICENSE_NO||' to '||:NEW.LICENSE_NO); 
	END IF;
	IF UPDATING('COMMISSION_PCT') THEN 
		INSERT INTO user_log (user_id, event_type, description) 
		VALUES (:NEW.user_id,'UPDATE COMMISSION_PCT','Your commission_pct changed from '||:old.COMMISSION_PCT||' to '||:new.COMMISSION_PCT);
		INSERT INTO admin_log (event_type, DESCRIPTION) 
		VALUES ('UPDATE COMMISSION_PCT','Commission_pct of '||:NEW.USER_ID || ' changed from '||:old.COMMISSION_PCT||' to '||:new.COMMISSION_PCT);
	END IF;
	IF UPDATING('EXPERTISE') THEN 
			INSERT INTO user_log (user_id, event_type, description) 
		VALUES (:NEW.user_id,'EXPERTISE UPDATE','Your expertise has been changed successfully');
			INSERT INTO admin_log (event_type, DESCRIPTION) 
		VALUES ('EXPERTISE UPDATE',:NEW.USER_ID||' has been changed expertise to '||:new.EXPERTISE);
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."SET_NULL_BROKER_ID" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."BROKER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
	IF :NEW.IS_DELETED = 'T' THEN 
		UPDATE CUSTOMER
		SET BROKER_ID = null 
		WHERE BROKER_ID = :NEW.USER_ID;
	END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table CORPORATION
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CORPORATION" ADD CONSTRAINT "PK_CORPORATION" PRIMARY KEY ("CORP_ID");

-- ----------------------------
-- Uniques structure for table CORPORATION
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CORPORATION" ADD CONSTRAINT "UK_CORPORATION_CORP_REG_NO" UNIQUE ("CORP_REG_NO") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Checks structure for table CORPORATION
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CORPORATION" ADD CONSTRAINT "CORP_DELETED_CHECK" CHECK (IS_DELETED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."CORPORATION" ADD CONSTRAINT "SYS_C008954" CHECK ("CORP_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."CORPORATION" ADD CONSTRAINT "SYS_C008955" CHECK ("CORP_REG_NO" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."CORPORATION" ADD CONSTRAINT "SYS_C008956" CHECK ("SECTOR" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Indexes structure for table CORPORATION
-- ----------------------------
CREATE INDEX "C##STOCKDB"."CORPORATION_SECTOR_IDX"
  ON "C##STOCKDB"."CORPORATION" ("SECTOR" ASC)
  LOGGING
  VISIBLE
PCTFREE 10
INITRANS 2
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
  FLASH_CACHE DEFAULT
)
   USABLE;

-- ----------------------------
-- Triggers structure for table CORPORATION
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."BLOCK_STOCK_ON_DELETING_CORP" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."CORPORATION" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF :NEW.IS_DELETED = 'T' THEN 
			UPDATE STOCK 
			SET BLOCKED = 'T'
			WHERE CORP_ID = :NEW.CORP_ID;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."DELETE_UPCOMING_ACTIVITY_ON_DELETING_CORP" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."CORPORATION" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF :NEW.IS_DELETED = 'T' THEN 
		DELETE FROM ACTIVITY
		WHERE CORP_ID = :NEW.CORP_ID AND START_TIME >= CURRENT_TIMESTAMP;
	END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table CUSTOMER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "PK_CUSTOMER" PRIMARY KEY ("USER_ID");

-- ----------------------------
-- Uniques structure for table CUSTOMER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "UK_ACCOUNT_NO" UNIQUE ("ACCOUNT_NO") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Checks structure for table CUSTOMER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "CUSTOMER_DELETED_CHECK" CHECK (IS_DELETED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "SYS_C008994" CHECK ("ACCOUNT_NO" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table CUSTOMER
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."CUSTOMER_DETAILS_UPDATE_LOG" AFTER UPDATE OF "ACCOUNT_NO", "BROKER_ID", "REFER_COUNT" ON "C##STOCKDB"."CUSTOMER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF UPDATING('ACCOUNT_NO') THEN 
		INSERT INTO user_log (user_id, event_type, description) 
		VALUES (:NEW.user_id,'UPDATE ACCOUNT_NO','Your account_no has been changed to '||:NEW.ACCOUNT_NO || ' successfully');
		INSERT INTO admin_log (event_type, DESCRIPTION) 
		VALUES ('UPDATE ACCOUNT_NO','Account_no of '||:NEW.USER_ID || ' changed from '||:OLD.ACCOUNT_NO||' to '||:NEW.ACCOUNT_NO); 
	END IF;
	IF UPDATING('REFER_COUNT') THEN 
		INSERT INTO user_log (user_id, event_type, description) 
		VALUES (:NEW.user_id,'UPDATE REFER_COUNT','Thank you for refering our site to another customer');
		INSERT INTO admin_log (event_type, DESCRIPTION) 
		VALUES ('UPDATE REFER_COUNT','REFER_COUNT of '||:NEW.USER_ID || ' changed from '||:OLD.REFER_COUNT||' to '||:NEW.REFER_COUNT);
		IF :OLD.REFER_COUNT = 3 AND :NEW.REFER_COUNT = 4 THEN 
				INSERT INTO user_log (user_id, event_type, description) 
				VALUES (:NEW.user_id,'PREMIUM','Congrats ! You are now a premium user');
		END IF;
	END IF;
	IF UPDATING('BROKER_ID') THEN 
			INSERT INTO user_log (user_id, event_type, description) 
		VALUES (:NEW.user_id,'BROKER UPDATE','Your broker has been changed successfully');
			INSERT INTO admin_log (event_type, DESCRIPTION) 
		VALUES ('BROKER UPDATE',:NEW.USER_ID||' has been changed broker to '||:new.BROKER_ID);
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."DELETE_PORTFOLIO_ON_DELETING_CUSTOMER" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."CUSTOMER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF :NEW.IS_DELETED = 'T' THEN 
		DELETE FROM PORTFOLIO 
		WHERE USER_ID = :NEW.USER_ID;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."REFERCOUNTUPDATE" BEFORE INSERT ON "C##STOCKDB"."CUSTOMER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
BEGIN
UPDATE CUSTOMER
SET REFER_COUNT = REFER_COUNT + 1
WHERE USER_ID = :NEW.REFERER_ID;
END;
/

-- ----------------------------
-- Primary Key structure for table EMPLOYEE
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "PK_EMPLOYEE" PRIMARY KEY ("EMPLOYEE_ID");

-- ----------------------------
-- Uniques structure for table EMPLOYEE
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "UK_EMPLOYEE_NID" UNIQUE ("NID") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "UK_EMP_EMAIL" UNIQUE ("EMAIL") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Checks structure for table EMPLOYEE
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_EMPLOYEE_DOB" CHECK (EXTRACT(YEAR FROM DOB) > 1900) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_EMPLOYEE_EMAIL_FORMAT" CHECK (REGEXP_LIKE(EMAIL, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9.-]{2,}$')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_EMPLOYEE_HIRE_DATE" CHECK (HIRE_DATE >= TO_DATE('2014-11-01', 'YYYY-MM-DD')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_EMPLOYEE_NID" CHECK (REGEXP_LIKE(NID, '^\d{3}-\d{2}-\d{4}$')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_EMPLOYEE_SEX" CHECK (SEX in ('M', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_EMP_EMAIL_FORMAT" CHECK (REGEXP_LIKE(EMAIL, '[a-z0-9]+@[a-z]+\.[a-z]{2,3}', 'i')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "CHK_SALARY_RANGE" CHECK (SALARY BETWEEN 10000.00 AND 1000000.00) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "EMP_DELETED_CHECK" CHECK (IS_DELETED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "SYS_C009042" CHECK ("EMPLOYEE_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "SYS_C009043" CHECK ("FIRST_NAME" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "SYS_C009044" CHECK ("LAST_NAME" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "SYS_C009045" CHECK ("EMAIL" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table EMPLOYEE
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."DELETE_EMP_CONTACT" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."EMPLOYEE" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
COUNT_CONTACT NUMBER;
BEGIN
	IF :NEW.IS_DELETED = 'T' THEN  
		SELECT COUNT(*) INTO COUNT_CONTACT FROM EMP_CONTACT WHERE EMPLOYEE_ID = :NEW.EMPLOYEE_ID;
		IF COUNT_CONTACT > 0 THEN 
			DELETE FROM EMP_CONTACT WHERE EMPLOYEE_ID = :NEW.EMPLOYEE_ID; 
		END IF;
	END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table EMP_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMP_CONTACT" ADD CONSTRAINT "PK_EMP_CONTACT" PRIMARY KEY ("EMPLOYEE_ID", "CONTACT");

-- ----------------------------
-- Checks structure for table EMP_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMP_CONTACT" ADD CONSTRAINT "CHK_EMP_CONTACT_FORMAT" CHECK ( REGEXP_LIKE ( CONTACT, '^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$' ) ) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMP_CONTACT" ADD CONSTRAINT "SYS_C009053" CHECK ("EMPLOYEE_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."EMP_CONTACT" ADD CONSTRAINT "SYS_C009054" CHECK ("CONTACT" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Primary Key structure for table ORDER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "PK_ORDER" PRIMARY KEY ("ORDER_ID");

-- ----------------------------
-- Checks structure for table ORDER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "CHK_ORDER_PRICES" CHECK (LATEST_PRICE >= 0 AND LATEST_QUANTITY >=0 AND TRANSACTION_FEE >= 0) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "CHK_ORDER_STATUS" CHECK (UPPER(STATUS) IN ('PENDING','SUCCESS','FAILURE')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "CHK_ORDER_TYPE" CHECK (UPPER("TYPE") IN ('BUY','SELL')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "SYS_C009003" CHECK ("ORDER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "SYS_C009004" CHECK ("SYMBOL" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ORDER" ADD CONSTRAINT "SYS_C009005" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Indexes structure for table ORDER
-- ----------------------------
CREATE INDEX "C##STOCKDB"."ORDER_SYMBOL_IDX"
  ON "C##STOCKDB"."ORDER" ("SYMBOL" ASC)
  LOGGING
  VISIBLE
PCTFREE 10
INITRANS 2
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
  FLASH_CACHE DEFAULT
)
   USABLE;
CREATE INDEX "C##STOCKDB"."ORDER_TRANSACTION_TIME_STATUS_IDX"
  ON "C##STOCKDB"."ORDER" ("TRANSACTION_TIME" ASC, "STATUS" ASC)
  LOGGING
  VISIBLE
PCTFREE 10
INITRANS 2
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
  FLASH_CACHE DEFAULT
)
   USABLE;

-- ----------------------------
-- Triggers structure for table ORDER
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."BUY_ORDER_ADMIN_FUNDS_CHECK" BEFORE INSERT OR UPDATE OF "LATEST_PRICE", "LATEST_QUANTITY" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(30);
FUND NUMBER(10,2);
BEGIN
    FUND := 0;
	SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
	IF TYP = 'Admin' THEN 
        SELECT FUNDS INTO FUND FROM ADMIN WHERE ADMIN_ID = :NEW.USER_ID;
        IF :NEW.LATEST_PRICE * :NEW.LATEST_QUANTITY > FUND THEN 
            RAISE_APPLICATION_ERROR(-20006,'Insufficient funds for transaction');
        END IF;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."BUY_ORDER_AMOUNT_CHECK" BEFORE INSERT OR UPDATE OF "LATEST_QUANTITY" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
NUM_SHARES NUMBER;
ALLOWED_SHARES NUMBER;
BEGIN
    IF :NEW."TYPE" = 'BUY' THEN
        SELECT LOT INTO NUM_SHARES FROM STOCK WHERE SYMBOL = :NEW.SYMBOL;
        SELECT LOT*AVAILABLE_LOTS INTO ALLOWED_SHARES FROM STOCK WHERE SYMBOL = :NEW.SYMBOL;
        IF :NEW.LATEST_QUANTITY*NUM_SHARES > ALLOWED_SHARES OR :NEW.LATEST_QUANTITY*NUM_SHARES <= 0 THEN 
            RAISE_APPLICATION_ERROR(-20003,'Invalid amount of stock');
        END IF;
            :NEW.LATEST_QUANTITY := :NEW.LATEST_QUANTITY*NUM_SHARES;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."BUY_ORDER_SUCCESS_ADMIN_FUNDS_CHECK" BEFORE UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(20);
FUND NUMBER(20,2);
FLAG NUMBER;
BEGIN 
	IF :NEW.STATUS = 'SUCCESS' THEN 
        SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
        IF TYP = 'Admin' THEN 
            SELECT COUNT(FUNDS) INTO FLAG 
            FROM ADMIN WHERE ADMIN_ID = :NEW.USER_ID;

            IF FLAG = 0 THEN 
                :NEW.STATUS := 'FAILURE'; 
            ELSE 
                SELECT FUNDS INTO FUND FROM ADMIN WHERE ADMIN_ID = :NEW.USER_ID;
                IF FUND < :NEW.LATEST_PRICE * :NEW.LATEST_QUANTITY THEN 
                    :NEW.STATUS := 'FAILURE'; 
								ELSE 
									 UPDATE ADMIN 
									 SET FUNDS = FUNDS - :NEW.LATEST_PRICE * :NEW.LATEST_QUANTITY 
									 WHERE ADMIN_ID = :NEW.USER_ID;
                END IF;
            END IF;
        END IF;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."BUY_ORDER_SUCCESS_UPDATE_AVAILABLE_LOTS_FROM_STOCK" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    IF :NEW.STATUS = 'SUCCESS' AND :NEW."TYPE" = 'BUY' THEN 
        UPDATE STOCK
        SET AVAILABLE_LOTS = AVAILABLE_LOTS - :NEW.LATEST_QUANTITY/(SELECT LOT FROM STOCK WHERE SYMBOL = :NEW.SYMBOL)
        WHERE SYMBOL = :NEW.SYMBOL;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."BUY_ORDER_SUCCESS_UPDATE_CUSTOMER_PORTFOLIO" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
FLAG NUMBER;
USID NUMBER;
USER_TYPE VARCHAR2(30);
BEGIN
    SELECT "TYPE" INTO USER_TYPE FROM "USER" WHERE USER_ID = :NEW.USER_ID;
    IF :NEW.STATUS = 'SUCCESS' AND :NEW."TYPE" = 'BUY' AND USER_TYPE = 'Customer' THEN 
				SELECT COUNT(*) INTO FLAG 
        FROM PORTFOLIO WHERE SECTOR = SECTOR_OF_STOCK(:NEW.SYMBOL) AND USER_ID = :NEW.USER_ID;
        
        IF FLAG = 0 THEN
            INSERT INTO PORTFOLIO VALUES (:NEW.USER_ID,SECTOR_OF_STOCK(:NEW.SYMBOL),:NEW.LATEST_PRICE*:NEW.LATEST_QUANTITY,0);
        ELSE 
            UPDATE PORTFOLIO
            SET BUY_AMOUNT = BUY_AMOUNT + :NEW.LATEST_PRICE*:NEW.LATEST_QUANTITY
            WHERE USER_ID = :NEW.USER_ID AND SECTOR = SECTOR_OF_STOCK(:NEW.SYMBOL);
        END IF;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."BUY_ORDER_SUCCESS_UPDATE_OWNS_OR_BACKUP_STOCK" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(20);
COUNT_SYM NUMBER;
FLAG NUMBER;
BEGIN 
    IF :NEW.STATUS = 'SUCCESS' AND :NEW."TYPE" = 'BUY' THEN 
        SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
        IF TYP = 'Admin' THEN
            SELECT COUNT(SYMBOL) INTO COUNT_SYM 
            FROM "BACKUP STOCK"
            WHERE SYMBOL = :NEW.SYMBOL;
            IF COUNT_SYM = 0 THEN
                INSERT INTO "BACKUP STOCK" VALUES (:NEW.SYMBOL,:NEW.LATEST_QUANTITY/(SELECT LOT FROM STOCK WHERE SYMBOL = :NEW.SYMBOL),'F');
            ELSE 
                UPDATE "BACKUP STOCK" 
                SET AVAILABLE_LOTS = AVAILABLE_LOTS + :NEW.LATEST_QUANTITY/(SELECT LOT FROM STOCK WHERE SYMBOL = :NEW.SYMBOL)
                WHERE SYMBOL = :NEW.SYMBOL;
            END IF;
        ELSIF TYP = 'Customer' THEN 
            SELECT COUNT(*) INTO FLAG FROM OWNS WHERE SYMBOL = :NEW.SYMBOL AND USER_ID = :NEW.USER_ID;
						
            IF FLAG = 0 THEN 
                INSERT INTO OWNS VALUES(:NEW.USER_ID,:NEW.SYMBOL,:NEW.LATEST_QUANTITY);
            ELSE 
                UPDATE OWNS
                SET QUANTITY = QUANTITY + :NEW.LATEST_QUANTITY
                WHERE USER_ID = :NEW.USER_ID AND SYMBOL = :NEW.SYMBOL;
            END IF;
        END IF;
		END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."LATEST_UPDATE_TIME_SET" BEFORE INSERT OR UPDATE ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    :NEW.LATEST_UPDATE_TIME := CURRENT_TIMESTAMP;
END;
/
CREATE TRIGGER "C##STOCKDB"."ORDER_DETAILS_LOG" AFTER UPDATE OF "LATEST_PRICE", "LATEST_QUANTITY" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
IF UPDATING('LATEST_QUANTITY') THEN 
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'UPDATE QUANTITY OF ORDER','Your changed latest quantity from '||:OLD.LATEST_QUANTITY||' to '||:new.LATEST_QUANTITY||' of order '||:new.ORDER_ID);
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('UPDATE QUANTITY OF ORDER',:new.user_id||' changed latest quantity from '||:OLD.LATEST_QUANTITY||' to '||:new.LATEST_QUANTITY||' of order '||:new.ORDER_ID);

END IF;
IF UPDATING('LATEST_PRICE') THEN 
INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'UPDATE PRICE OF ORDER','Your changed latest price from '||:OLD.LATEST_PRICE||' to '||:new.LATEST_PRICE||' of order '||:new.ORDER_ID);
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('UPDATE PRICE OF ORDER',:new.user_id||' changed latest price from '||:OLD.LATEST_PRICE||' to '||:new.LATEST_PRICE||' of order '||:new.ORDER_ID);
END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."ORDER_PLACEMENT_LOG" AFTER INSERT ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
CORPID NUMBER(10);
NAME VARCHAR2(20);
BEGIN 
	SELECT CORP_ID INTO CORPID FROM STOCK WHERE SYMBOL = :NEW.SYMBOL;
	SELECT NAME INTO NAME FROM "USER" WHERE USER_ID = :NEW.USER_ID;
	IF :NEW."TYPE" = 'BUY' THEN 
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'BUY','Your buy order has been placed successfully');
	
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (CORPID,'BUY',NAME||' placed a buy order for your stock;amount '||:new.LATEST_QUANTITY||' and price '||:new.LATEST_PRICE);
	
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('BUY',:new.USER_ID||' placed a buy order for '||:new.SYMBOL||';amount '||:new.LATEST_QUANTITY||' and price '||:new.LATEST_PRICE);

	ELSIF :NEW."TYPE" = 'SELL' THEN 
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'SELL','Your sell order has been placed successfully');	
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('SELL',:new.USER_ID||' placed a sell order for '||:new.SYMBOL||';amount '||:new.LATEST_QUANTITY||' and price '||:new.LATEST_PRICE);
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."ORDER_STATUS_LOG" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
CORPID NUMBER(10);
NAME VARCHAR2(20);
BEGIN 
	SELECT CORP_ID INTO CORPID FROM STOCK WHERE SYMBOL = :NEW.SYMBOL;
	SELECT NAME INTO NAME FROM "USER" WHERE USER_ID = :NEW.USER_ID; 
	IF :NEW."TYPE" = 'BUY' THEN 
		INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'BUY STATUS','Your buy order '||:new.ORDER_ID||' is a '||:new.STATUS);
	
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (CORPID,'BUY STATUS','The buy order '||:new.ORDER_ID||' placed by '||NAME||' is a '||:new.STATUS);
	
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('BUY STATUS','Buy order '||:new.ORDER_ID||' of '||:NEW.USER_ID||' is a '||:new.STATUS);
	ELSIF :new."TYPE" = 'SELL' THEN 
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'SELL STATUS','Your sell order '||:new.ORDER_ID||' is a '||:new.STATUS);
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('SELL STATUS','Sell order '||:new.ORDER_ID||' of '||:NEW.USER_ID||' is a '||:new.STATUS);
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."ORDER_SUCCESS_UPDATE_STOCK_LTP" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    IF :NEW.STATUS = 'SUCCESS' THEN
        UPDATE STOCK 
        SET LTP = :NEW.LATEST_PRICE
        WHERE SYMBOL = :NEW.SYMBOL;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."PLACE_ORDER_SYMBOL_CHECK" BEFORE INSERT ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
COUNT_SYM NUMBER;
BEGIN
	SELECT COUNT(*) INTO COUNT_SYM FROM 
    (SELECT SYMBOL FROM STOCK WHERE SYMBOL = :NEW.SYMBOL AND BLOCKED = 'F');  
	IF COUNT_SYM = 0 THEN  
        RAISE_APPLICATION_ERROR(-20002,'Invalid stock');
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."PLACE_ORDER_USER_CHECK" BEFORE INSERT ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(20);
NUM NUMBER;
BEGIN
    SELECT COUNT(*) INTO NUM FROM 
    (SELECT "TYPE" FROM "USER" WHERE USER_ID = :NEW.USER_ID);
    IF NUM = 0 THEN 
        RAISE_APPLICATION_ERROR(-20000,'User Not Found');
    ELSE 
        SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
        IF TYP NOT IN ('Admin','Customer') THEN 
            RAISE_APPLICATION_ERROR(-20001,'User not permitted');
        END IF;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."SELL_ORDER_AMOUNT_CHECK" BEFORE INSERT OR UPDATE OF "LATEST_QUANTITY" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(20);
FLAG NUMBER;
NUM_SHARES NUMBER;
AVAILABLE_SHARE_LOTS NUMBER;
AVAILABLE_SHARES NUMBER;
BEGIN
    SELECT LOT INTO NUM_SHARES FROM STOCK WHERE SYMBOL = :NEW.SYMBOL;
    IF :NEW."TYPE" = 'SELL' THEN
        SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
        IF TYP = 'Admin' THEN
            SELECT COUNT(SYMBOL) INTO FLAG 
            FROM "BACKUP STOCK"
            WHERE SYMBOL = :NEW.SYMBOL;

            IF FLAG = 0 THEN 
                RAISE_APPLICATION_ERROR(-20003,'Invalid amount of stock');
            ELSE 
                SELECT AVAILABLE_LOTS INTO AVAILABLE_SHARE_LOTS 
                FROM "BACKUP STOCK"
                WHERE SYMBOL = :NEW.SYMBOL;
                IF :NEW.LATEST_QUANTITY > AVAILABLE_SHARE_LOTS OR :NEW.LATEST_QUANTITY*NUM_SHARES <= 0 THEN 
                    RAISE_APPLICATION_ERROR(-20003,'Invalid amount of stock');
                END IF;
            END IF;
        ELSIF TYP = 'Customer' THEN
            SELECT COUNT(*) INTO FLAG 
            FROM OWNS 
            WHERE 
            USER_ID = :NEW.USER_ID AND 
            SYMBOL = :NEW.SYMBOL;

            IF FLAG = 0 THEN 
                RAISE_APPLICATION_ERROR(-20003,'Invalid amount of stock');
            END IF;

            SELECT 
                QUANTITY INTO AVAILABLE_SHARES 
            FROM OWNS 
            WHERE 
                USER_ID = :NEW.USER_ID AND 
                SYMBOL = :NEW.SYMBOL;
            IF :NEW.LATEST_QUANTITY * NUM_SHARES > AVAILABLE_SHARES  OR :NEW.LATEST_QUANTITY*NUM_SHARES <= 0 THEN 
                RAISE_APPLICATION_ERROR(-20003,'Invalid amount of stock');
            END IF;
        ELSE 
            RAISE_APPLICATION_ERROR(-20001,'User not permitted');
        END IF;
        :NEW.LATEST_QUANTITY := :NEW.LATEST_QUANTITY*NUM_SHARES;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."SELL_ORDER_STATUS_CHECK" BEFORE UPDATE ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    IF :NEW.STATUS = 'FAILURE' AND :NEW."TYPE" = 'SELL' THEN 
		RAISE_APPLICATION_ERROR(-20004,'Sell order can never fail');
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."SELL_ORDER_SUCCESS_UPDATE_CUSTOMER_PORTFOLIO" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
FLAG NUMBER;
USID NUMBER;
USER_TYPE VARCHAR2(30);
BEGIN 
    SELECT "TYPE" INTO USER_TYPE FROM "USER" WHERE USER_ID = :NEW.USER_ID;
    IF :NEW.STATUS = 'SUCCESS' AND :NEW."TYPE" = 'SELL' AND USER_TYPE = 'Customer' THEN 
				SELECT COUNT(*) INTO FLAG 
        FROM PORTFOLIO WHERE SECTOR = SECTOR_OF_STOCK(:NEW.SYMBOL) AND USER_ID = :NEW.USER_ID;
        
        IF FLAG = 0 THEN
            INSERT INTO PORTFOLIO VALUES (:NEW.USER_ID,SECTOR_OF_STOCK(:NEW.SYMBOL),0,:NEW.LATEST_PRICE*:NEW.LATEST_QUANTITY);
        ELSE 
            UPDATE PORTFOLIO
            SET SELL_AMOUNT = SELL_AMOUNT + :NEW.LATEST_PRICE*:NEW.LATEST_QUANTITY
            WHERE USER_ID = :NEW.USER_ID AND SECTOR = SECTOR_OF_STOCK(:NEW.SYMBOL);
        END IF;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."SELL_ORDER_SUCCESS_UPDATE_OWNS_OR_BACKUP_STOCK" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(20);
SYM VARCHAR2(40);
USID NUMBER;
BEGIN 
    IF :NEW.STATUS = 'SUCCESS' AND :NEW."TYPE" = 'SELL' THEN 
        SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
        IF TYP = 'Admin' THEN
            UPDATE "BACKUP STOCK" 
            SET AVAILABLE_LOTS = AVAILABLE_LOTS - :NEW.LATEST_QUANTITY/(SELECT LOT FROM STOCK WHERE SYMBOL = :NEW.SYMBOL)
            WHERE SYMBOL = :NEW.SYMBOL;
        ELSIF TYP = 'Customer' THEN 
            UPDATE OWNS
            SET QUANTITY = QUANTITY - :NEW.LATEST_QUANTITY
            WHERE USER_ID = :NEW.USER_ID AND SYMBOL = :NEW.SYMBOL;
        END IF;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."TRANSACTION_FEE_SET" BEFORE INSERT OR UPDATE ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
TYP VARCHAR2(20);
BEGIN
    IF :NEW.STATUS = 'FAILURE' THEN
        :NEW.TRANSACTION_FEE := 0;
    ELSE 
        SELECT "TYPE" INTO TYP FROM "USER" WHERE USER_ID = :NEW.USER_ID;
        IF TYP = 'Admin' THEN 
            :NEW.TRANSACTION_FEE := 0;
        ELSIF TYP = 'Customer' THEN  
            :NEW.TRANSACTION_FEE := ROUND(:NEW.LATEST_PRICE * :NEW.LATEST_QUANTITY * 2 / 100,2);
        END IF;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."TRANSACTION_TIME_SET" BEFORE UPDATE ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    IF :NEW.STATUS = 'SUCCESS' THEN 
        :NEW.TRANSACTION_TIME := CURRENT_TIMESTAMP;
    ELSE 
		:NEW.TRANSACTION_TIME := NULL;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_BROKER_COMMISSION_PCT" AFTER UPDATE OF "STATUS" ON "C##STOCKDB"."ORDER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
NEW_COM_PCT NUMBER(5,2);
OLD_COM_PCT NUMBER(5,2);
BID NUMBER;
USER_TYPE VARCHAR2(30);
BEGIN 
    SELECT "TYPE" INTO USER_TYPE FROM "USER" WHERE USER_ID = :NEW.USER_ID;
    IF :NEW.STATUS = 'SUCCESS' AND USER_TYPE = 'Customer' THEN
        SELECT COUNT(BROKER_ID) INTO BID FROM CUSTOMER WHERE USER_ID = :NEW.USER_ID;
        IF BID <> 0 THEN
            SELECT BROKER_ID INTO BID FROM CUSTOMER WHERE USER_ID = :NEW.USER_ID;
            NEW_COM_PCT := BROKER_COMMISSION_PCT(BID);
            SELECT NVL(COMMISSION_PCT,0) INTO OLD_COM_PCT FROM BROKER WHERE USER_ID = BID;
            IF OLD_COM_PCT < NEW_COM_PCT THEN
                UPDATE BROKER 
                SET COMMISSION_PCT = NEW_COM_PCT
                WHERE USER_ID = BID;
            END IF;
        END IF;
    END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table OWNS
-- ----------------------------
ALTER TABLE "C##STOCKDB"."OWNS" ADD CONSTRAINT "PK_OWNS" PRIMARY KEY ("USER_ID", "SYMBOL");

-- ----------------------------
-- Checks structure for table OWNS
-- ----------------------------
ALTER TABLE "C##STOCKDB"."OWNS" ADD CONSTRAINT "SYS_C009013" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."OWNS" ADD CONSTRAINT "SYS_C009015" CHECK ("SYMBOL" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table OWNS
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."OWNS_LOG" AFTER INSERT OR UPDATE OF "QUANTITY" ON "C##STOCKDB"."OWNS" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF INSERTING THEN
		INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:new.USER_ID,'NEW OWNERSHIP','You now own '||:new.QUANTITY||' of '||:new.SYMBOL);
		INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('NEW OWNERSHIP',:new.user_id||' now owns '||:new.QUANTITY||' of '||:new.SYMBOL);
	ELSIF UPDATING('QUANTITY') THEN 
		INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:new.USER_ID,'UPDATE OWNERSHIP','Your owns of '||:new.SYMBOL||' changed from '||:old.QUANTITY||' to '||:new.QUANTITY);
		INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('UPDATE OWNERSHIP',:new.user_id||' owns of '||:new.SYMBOL||' changed from '||:old.QUANTITY||' to '||:new.QUANTITY);
	END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table PARTICIPATION
-- ----------------------------
ALTER TABLE "C##STOCKDB"."PARTICIPATION" ADD CONSTRAINT "PK_PARTICIPATION" PRIMARY KEY ("ACTIVITY_ID", "USER_ID");

-- ----------------------------
-- Checks structure for table PARTICIPATION
-- ----------------------------
ALTER TABLE "C##STOCKDB"."PARTICIPATION" ADD CONSTRAINT "SYS_C009102" CHECK ("ACTIVITY_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."PARTICIPATION" ADD CONSTRAINT "SYS_C009103" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table PARTICIPATION
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."PARTICIPATION_LOG" AFTER INSERT ON "C##STOCKDB"."PARTICIPATION" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
EVENT_DATE VARCHAR2(30);
"START TIME" VARCHAR2(30);
CORPID NUMBER(10);
NAME VARCHAR2(20);
BEGIN 
	SELECT TO_CHAR( "DATE", 'DD Month YYYY' ) INTO EVENT_DATE FROM ACTIVITY WHERE ACTIVITY_ID = :NEW.ACTIVITY_ID;
	SELECT TIME_FORMAT ( START_TIME ) INTO "START TIME" FROM ACTIVITY WHERE ACTIVITY_ID = :NEW.ACTIVITY_ID;
	SELECT CORP_ID INTO CORPID FROM ACTIVITY WHERE ACTIVITY_ID = :NEW.ACTIVITY_ID;
	SELECT NAME INTO NAME FROM "USER" WHERE USER_ID = :NEW.USER_ID; 
	
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'PARTICIPATING','Registration confirmed . Event on '||EVENT_DATE||' at '||"START TIME");
	
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (CORPID,'NEW PARTICIPATION',NAME||' is participating in your event on '||EVENT_DATE);
	
	
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('NEW PARTICIPATION',:new.USER_ID||' is participating in '||:new.ACTIVITY_ID);
END;
/

-- ----------------------------
-- Primary Key structure for table PORTFOLIO
-- ----------------------------
ALTER TABLE "C##STOCKDB"."PORTFOLIO" ADD CONSTRAINT "PK_PORTFOLIO" PRIMARY KEY ("USER_ID", "SECTOR");

-- ----------------------------
-- Checks structure for table PORTFOLIO
-- ----------------------------
ALTER TABLE "C##STOCKDB"."PORTFOLIO" ADD CONSTRAINT "SYS_C008999" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."PORTFOLIO" ADD CONSTRAINT "SYS_C009000" CHECK ("SECTOR" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table PORTFOLIO
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."PORTFOLIO_LOG" AFTER INSERT OR UPDATE OF "BUY_AMOUNT", "SELL_AMOUNT" ON "C##STOCKDB"."PORTFOLIO" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
	IF INSERTING THEN 
		INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'NEW PORTFOLIO','You have bought '||:new.BUY_AMOUNT||' and sold '||:new.SELL_AMOUNT||' in '||:new.SECTOR);
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('NEW PORTFOLIO',:new.USER_ID||' has bought '||:new.BUY_AMOUNT||' and sold '||:new.SELL_AMOUNT||' in '||:new.SECTOR);
	ELSIF UPDATING('BUY_AMOUNT') THEN
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'UPDATE BUY AMOUNT','You now have bought '||:new.BUY_AMOUNT||' in '||:new.SECTOR);
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('UPDATE BUY AMOUNT','Buy amount of '||:new.USER_ID||' has changed from '||:old.BUY_AMOUNT||' to '||:new.BUY_AMOUNT||' in '||:new.SECTOR);
	ELSIF UPDATING('SELL_AMOUNT') THEN 
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'UPDATE SELL AMOUNT','You now have sold '||:new.SELL_AMOUNT||' in '||:new.SECTOR);
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('UPDATE SELL AMOUNT','Sell amount of '||:new.USER_ID||' has changed from '||:old.sell_AMOUNT||' to '||:new.sell_AMOUNT||' in '||:new.SECTOR);
	END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table STOCK
-- ----------------------------
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "PK_STOCK_SYMBOL" PRIMARY KEY ("SYMBOL");

-- ----------------------------
-- Checks structure for table STOCK
-- ----------------------------
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "CHK_BLOCKED" CHECK (BLOCKED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "CHK_STOCK_NON_NEGATIVE" CHECK (PRICE >= 0 AND VALUE >= 0 AND LTP >= 0 AND AVAILABLE_LOTS >= 0) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "SYS_C008959" CHECK ("SYMBOL" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "SYS_C008960" CHECK ("UPDATE_TIME" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "SYS_C008961" CHECK ("VALUE" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "SYS_C008962" CHECK ("PRICE" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "SYS_C008963" CHECK ("LTP" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table STOCK
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."DELETE_ORDER_ON_BLOCKING_STOCK" AFTER UPDATE OF "BLOCKED" ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF :NEW.BLOCKED = 'T' THEN 
		DELETE FROM "ORDER" 
		WHERE SYMBOL = :NEW.SYMBOL AND STATUS = 'PENDING';
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."INSERT_CORP_INTO_OWNS" AFTER INSERT ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
IF :NEW.AVAILABLE_LOTS IS NOT NULL AND :NEW.LOT IS NOT NULL THEN 
	INSERT INTO OWNS VALUES(:NEW.CORP_ID,:NEW.SYMBOL,:NEW.AVAILABLE_LOTS*:NEW.LOT);
END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."STOCK_LOG_TRIGGER" AFTER INSERT OR UPDATE OF "AVAILABLE_LOTS", "BLOCKED", "LTP", "PRICE", "SYMBOL", "VALUE" ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
    old_symbol VARCHAR2(255);
    old_price NUMBER;
    old_value NUMBER;
    old_available_lots NUMBER;
    old_ltp NUMBER;
    old_blocked VARCHAR2(2);
BEGIN
  -- Get the old values of the updated fields
  
  
    old_symbol := :OLD.symbol;
    old_price := :OLD.price;
    old_value := :OLD.value;
    old_available_lots := :OLD.available_lots;
    old_ltp := :OLD.ltp;
    old_blocked := :OLD.blocked;
  

  -- Insert a row into the admin_log table
  IF INSERTING THEN
		INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK INSERT','Your symbol '||:new.SYMBOL||' has been registered');
	
	
    INSERT INTO admin_log (event_type, description, event_time)
    VALUES ('INSERT',
           'New stock ' || :NEW.symbol || ' added',
           SYSDATE);
  ELSIF UPDATING THEN
    IF :NEW.symbol != :OLD.symbol THEN
			INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK UPDATE','Your symbol updated from ' || old_symbol || ' to ' || :NEW.symbol);
		
      INSERT INTO admin_log (event_type, description, event_time)
      VALUES ('UPDATE',
              'Symbol updated from ' || old_symbol || ' to ' || :NEW.symbol,
              SYSDATE);
    END IF;

    IF :NEW.price != :OLD.price THEN
			INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK UPDATE','Your price updated from ' || old_price || ' to ' || :NEW.price);
		
      INSERT INTO admin_log (event_type, description, event_time)
      VALUES ('UPDATE',
              'Price of '|| :new.symbol ||' updated from ' || old_price || ' to ' || :NEW.price,
              SYSDATE);
    END IF;

    IF :NEW.value != :OLD.value THEN
			INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK UPDATE','Your value updated from ' || old_value || ' to ' || :NEW.VALUE);
	
      INSERT INTO admin_log (event_type, description, event_time)
      VALUES ('UPDATE',
              'Value of '|| :new.symbol ||' updated from ' || old_value || ' to ' || :NEW.value,
              SYSDATE);
    END IF;

    IF :NEW.available_lots != :OLD.available_lots THEN
			INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK UPDATE','Your available lots updated from ' || old_available_lots || ' to ' || :NEW.available_lots);
		
      INSERT INTO admin_log (event_type, description, event_time)
      VALUES ('UPDATE',
              'Available lots of '|| :new.symbol ||' updated from ' || old_available_lots || ' to ' || :NEW.available_lots,
              SYSDATE);
    END IF;

    IF :NEW.ltp != :OLD.ltp THEN
			INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK UPDATE','Your ltp updated from ' || old_ltp || ' to ' || :NEW.ltp);
		
		
      INSERT INTO admin_log (event_type, description, event_time)
      VALUES ('UPDATE',
              'LTP of '|| :new.symbol ||' updated from ' || old_ltp || ' to ' || :NEW.ltp,
              SYSDATE);
    END IF;

    IF :NEW.blocked != :OLD.blocked THEN
			INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.CORP_ID,'STOCK UPDATE','Your blocked status updated from ' || old_blocked || ' to ' || :NEW.blocked);
		
		
      INSERT INTO admin_log (event_type, description, event_time)
      VALUES ('UPDATE',
              'Blocked status of '|| :new.symbol ||' updated from ' || old_blocked || ' to ' || :NEW.blocked,
              SYSDATE);
    END IF;
  END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_BLOCKED_FLAG" AFTER UPDATE OF "BLOCKED" ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE 
COUNT_SYM NUMBER;
BEGIN
		SELECT COUNT(SYMBOL) INTO COUNT_SYM FROM "BACKUP STOCK" WHERE SYMBOL = :NEW.SYMBOL;
		IF COUNT_SYM = 0 THEN 
			UPDATE "BACKUP STOCK"
			SET blocked = :NEW.BLOCKED
			WHERE SYMBOL = :new.SYMBOL;
		END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_CORRESPONDING_SYMBOLS" AFTER UPDATE OF "SYMBOL" ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    -- Update symbol in BACKUP_STOCK
		UPDATE "BACKUP STOCK"
		SET SYMBOL = :new.SYMBOL
		WHERE SYMBOL = :old.SYMBOL;
    
    -- Update symbol in ORDER
    UPDATE "ORDER"
    SET SYMBOL = :new.SYMBOL
    WHERE SYMBOL = :old.SYMBOL;
    
    -- Update symbol in OWNS
    UPDATE OWNS
    SET SYMBOL = :new.SYMBOL
    WHERE SYMBOL = :old.SYMBOL;
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_QUANTITY_OF_STOCK" AFTER UPDATE OF "AVAILABLE_LOTS", "LOT" ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
UPDATE OWNS 
SET QUANTITY = :NEW.AVAILABLE_LOTS*:NEW.LOT 
WHERE USER_ID = :NEW.CORP_ID AND SYMBOL = :NEW.SYMBOL;
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_STOCK_TIME" BEFORE UPDATE ON "C##STOCKDB"."STOCK" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    :NEW.UPDATE_TIME := CURRENT_TIMESTAMP;
END;
/

-- ----------------------------
-- Primary Key structure for table USER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "PK_USER" PRIMARY KEY ("USER_ID");

-- ----------------------------
-- Uniques structure for table USER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "UK_USER_EMAIL" UNIQUE ("EMAIL") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Checks structure for table USER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "CHK_PWD_LENGTH" CHECK (LENGTH(PWD) = 128) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "CHK_REG_DATE" CHECK (REG_DATE >= TO_DATE('2015-01-01', 'YYYY-MM-DD')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "CHK_USER_EMAIL_FORMAT" CHECK (REGEXP_LIKE(EMAIL, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9.-]{2,}$')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "CHK_USER_TYPE" CHECK ("TYPE" IN ('Admin','Corp','Broker','Customer')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008913" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008914" CHECK ("NAME" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008915" CHECK ("PWD" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008916" CHECK ("EMAIL" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008917" CHECK ("TYPE" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008918" CHECK ("CITY" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008919" CHECK ("COUNTRY" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008920" CHECK ("ZIP" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "SYS_C008921" CHECK ("REG_DATE" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER" ADD CONSTRAINT "USER_DELETED_CHECK" CHECK (IS_DELETED IN ('T', 'F')) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table USER
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."DELETE_ORDER_ON_DELETING_USER" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF :NEW.IS_DELETED = 'T' THEN 
		DELETE FROM "ORDER" 
		WHERE USER_ID = :NEW.USER_ID AND STATUS = 'PENDING';
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."DELETE_OWNS_ON_DELETING_USER" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	IF :NEW.IS_DELETED = 'T' THEN 
			DELETE FROM OWNS 
			WHERE USER_ID = :NEW.USER_ID;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."DELETE_PARTICIPATION_ON_DELETING_USER" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
START_DATE TIMESTAMP;
BEGIN 
	IF :NEW.IS_DELETED = 'T' THEN 
		FOR R IN (
			SELECT ACTIVITY_ID 
			FROM PARTICIPATION WHERE 
			USER_ID = :NEW.USER_ID
		)
		LOOP 
		SELECT START_TIME INTO START_DATE FROM ACTIVITY WHERE ACTIVITY_ID = R.ACTIVITY_ID;
		IF START_DATE >= CURRENT_TIMESTAMP THEN 
			DELETE FROM PARTICIPATION 
			WHERE ACTIVITY_ID = R.ACTIVITY_ID AND USER_ID = :NEW.USER_ID;
		END IF;
		END LOOP;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."DELETE_USER" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
	IF :NEW.IS_DELETED = 'T' THEN  
	INSERT INTO user_log (user_id, event_type, description) 
	VALUES (:NEW.user_id,'DELETE','Account of '||:OLD.NAME || ' has been deleted');
	INSERT INTO admin_log (event_type, DESCRIPTION) 
	VALUES ('DELETE','Account of '||:OLD.USER_ID || ' has been deleted');
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."DELETE_USER_CONTACT" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
COUNT_CONTACT NUMBER;
BEGIN
	IF :NEW.IS_DELETED = 'T' THEN  
		SELECT COUNT(*) INTO COUNT_CONTACT FROM USER_CONTACT WHERE USER_ID = :NEW.USER_ID;
		IF COUNT_CONTACT > 0 THEN 
			DELETE FROM USER_CONTACT WHERE USER_ID = :NEW.USER_ID; 
		END IF;
	END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."INSERT_REG_DATE" BEFORE INSERT ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
		: NEW.REG_DATE := SYSDATE;
	
END;
/
CREATE TRIGGER "C##STOCKDB"."REG_USER" AFTER INSERT ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN 
	INSERT INTO USER_LOG(USER_ID,EVENT_TYPE,DESCRIPTION) VALUES (:NEW.USER_ID,'Register','Congrats '||:new.name||' , you have been registered');
	INSERT INTO ADMIN_LOG(EVENT_TYPE,DESCRIPTION) VALUES ('Register','New '||INITCAP(:NEW."TYPE")||' '||:NEW.USER_ID||' has registered successfully');
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_DELETED_FLAG" AFTER UPDATE OF "IS_DELETED" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
    IF :old."TYPE" = 'Customer' THEN
        UPDATE customer
        SET IS_DELETED = :NEW.IS_DELETED
        WHERE user_id = :new.user_id;
    ELSIF :old."TYPE" = 'Corp' THEN
        UPDATE corporation
        SET IS_DELETED = :NEW.IS_DELETED
        WHERE corp_id = :new.user_id;
    ELSIF :old."TYPE" = 'Broker' THEN
        UPDATE broker
        SET IS_DELETED = :NEW.IS_DELETED
        WHERE user_id = :new.user_id;
    ELSIF :old."TYPE" = 'Admin' THEN
        UPDATE admin
        SET IS_DELETED = :NEW.IS_DELETED
        WHERE admin_id = :new.user_id;
    END IF;
END;
/
CREATE TRIGGER "C##STOCKDB"."UPDATE_USER" AFTER UPDATE OF "CITY", "COUNTRY", "EMAIL", "NAME", "STREET_NAME", "STREET_NO", "ZIP" ON "C##STOCKDB"."USER" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
DECLARE
    old_name VARCHAR2(255);
    old_email VARCHAR2(255);
    old_street_no NUMBER;
    old_street_name VARCHAR2(255);
    old_city VARCHAR2(255);
    old_country VARCHAR2(255);
    old_zip VARCHAR2(20);
BEGIN
  -- Get the old values of the updated fields
  
  
    old_name := :OLD.name;
    old_email := :OLD.email;
    old_street_no := :OLD.street_no;
    old_street_name := :OLD.street_name;
    old_city := :OLD.city;
    old_country := :OLD.country;
    old_zip := :OLD.zip;

  -- Insert a row into the user_log table
  IF :NEW.name != :OLD.name THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'Name updated from ' || old_name || ' to ' || :NEW.name, SYSDATE);
  END IF;

  IF :NEW.email != :OLD.email THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'Email updated from ' || old_email || ' to ' || :NEW.email, SYSDATE);
  END IF;

  IF :NEW.street_no != :OLD.street_no THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'Street no updated from ' || old_street_no || ' to ' || :NEW.street_no, SYSDATE);
  END IF;

  IF :NEW.street_name != :OLD.street_name THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'Street name updated from ' || old_street_name || ' to ' || :NEW.street_name, SYSDATE);
  END IF;

  IF :NEW.city != :OLD.city THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'City updated from ' || old_city || ' to ' || :NEW.city, SYSDATE);
  END IF;

  IF :NEW.country != :OLD.country THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'Country updated from ' || old_country || ' to ' || :NEW.country, SYSDATE);
  END IF;

  IF :NEW.zip != :OLD.zip THEN
    INSERT INTO user_log (user_id, event_type, description, event_time)
    VALUES (:NEW.user_id, 'UPDATE', 'Zip updated from ' || old_zip || ' to ' || :NEW.zip, SYSDATE);
  END IF;

  -- Insert a row into the admin_log table
  INSERT INTO admin_log (event_type, DESCRIPTION, event_time)
  VALUES ('UPDATE',
         'User information updated for user_id = ' || :NEW.user_id,
         SYSDATE);
END;
/

-- ----------------------------
-- Primary Key structure for table USER_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER_CONTACT" ADD CONSTRAINT "PK_USER_CONTACT" PRIMARY KEY ("USER_ID", "CONTACT");

-- ----------------------------
-- Uniques structure for table USER_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER_CONTACT" ADD CONSTRAINT "UK_USER_CONTACT" UNIQUE ("CONTACT") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Checks structure for table USER_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER_CONTACT" ADD CONSTRAINT "CHK_CONTACT_FORMAT" CHECK ( REGEXP_LIKE ( CONTACT, '^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$' ) ) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER_CONTACT" ADD CONSTRAINT "SYS_C008927" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER_CONTACT" ADD CONSTRAINT "SYS_C008928" CHECK ("CONTACT" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Triggers structure for table USER_CONTACT
-- ----------------------------
CREATE TRIGGER "C##STOCKDB"."MOD_CONTACT" AFTER DELETE OR INSERT ON "C##STOCKDB"."USER_CONTACT" REFERENCING OLD AS "OLD" NEW AS "NEW" FOR EACH ROW 
BEGIN
IF INSERTING THEN 
  INSERT INTO user_log (user_id, event_type, description)
  VALUES (:NEW.user_id, 'ADD_CONTACT','New contact added ' || :NEW.contact);

  INSERT INTO admin_log (event_type, description)
  VALUES ('ADD_CONTACT', :NEW.user_id || ' has added contact ' || :NEW.contact);
ELSIF DELETING THEN 
	INSERT INTO user_log (user_id, event_type, description)
  VALUES (:OLD.user_id, 'DELETE_CONTACT','Contact deleted ' || :OLD.contact);

  INSERT INTO admin_log (event_type, description)
  VALUES ('DELETE_CONTACT', :OLD.user_id || ' has deleted contact ' || :OLD.contact);
END IF;
END;
/

-- ----------------------------
-- Primary Key structure for table USER_LOG
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER_LOG" ADD CONSTRAINT "PK_USER_LOG" PRIMARY KEY ("USER_LOG_ID");

-- ----------------------------
-- Checks structure for table USER_LOG
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER_LOG" ADD CONSTRAINT "SYS_C009324" CHECK ("USER_LOG_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."USER_LOG" ADD CONSTRAINT "SYS_C009325" CHECK ("USER_ID" IS NOT NULL) NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Indexes structure for table USER_LOG
-- ----------------------------
CREATE INDEX "C##STOCKDB"."USER_LOG_USER_ID_IDX"
  ON "C##STOCKDB"."USER_LOG" ("USER_ID" ASC)
  LOGGING
  VISIBLE
PCTFREE 10
INITRANS 2
STORAGE (
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1
  MAXEXTENTS 2147483645
  BUFFER_POOL DEFAULT
  FLASH_CACHE DEFAULT
)
   USABLE;

-- ----------------------------
-- Foreign Keys structure for table ACTIVITY
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ACTIVITY" ADD CONSTRAINT "FK_ACTIVITY_CORP_ID" FOREIGN KEY ("CORP_ID") REFERENCES "C##STOCKDB"."CORPORATION" ("CORP_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table ADMIN
-- ----------------------------
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "FK_ADMIN_ADDER_ID" FOREIGN KEY ("ADDER_ID") REFERENCES "C##STOCKDB"."ADMIN" ("ADMIN_ID") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "FK_ADMIN_EMPLOYEE_ID" FOREIGN KEY ("EMPLOYEE_ID") REFERENCES "C##STOCKDB"."EMPLOYEE" ("EMPLOYEE_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."ADMIN" ADD CONSTRAINT "FK_ADMIN_USER_ID" FOREIGN KEY ("ADMIN_ID") REFERENCES "C##STOCKDB"."USER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table BROKER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."BROKER" ADD CONSTRAINT "FK_BROKER_USER_ID" FOREIGN KEY ("USER_ID") REFERENCES "C##STOCKDB"."USER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table CORPORATION
-- ----------------------------

-- ----------------------------
-- Foreign Keys structure for table CUSTOMER
-- ----------------------------
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "FK_CUSTOMER_BROKER_ID" FOREIGN KEY ("BROKER_ID") REFERENCES "C##STOCKDB"."BROKER" ("USER_ID") ON DELETE SET NULL NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "FK_CUSTOMER_REFER_ID" FOREIGN KEY ("REFERER_ID") REFERENCES "C##STOCKDB"."CUSTOMER" ("USER_ID") ON DELETE SET NULL NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."CUSTOMER" ADD CONSTRAINT "FK_CUSTOMER_USER_ID" FOREIGN KEY ("USER_ID") REFERENCES "C##STOCKDB"."USER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table EMPLOYEE
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMPLOYEE" ADD CONSTRAINT "FK_EMPLOYEE_MANAGER_ID" FOREIGN KEY ("MANAGER_ID") REFERENCES "C##STOCKDB"."EMPLOYEE" ("EMPLOYEE_ID") NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table EMP_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."EMP_CONTACT" ADD CONSTRAINT "FK_EMP_CONTACT_EMPLOYEE_ID" FOREIGN KEY ("EMPLOYEE_ID") REFERENCES "C##STOCKDB"."EMPLOYEE" ("EMPLOYEE_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table ORDER
-- ----------------------------

-- ----------------------------
-- Foreign Keys structure for table OWNS
-- ----------------------------
ALTER TABLE "C##STOCKDB"."OWNS" ADD CONSTRAINT "FK_OWNS_STOCK_SYMBOL" FOREIGN KEY ("SYMBOL") REFERENCES "C##STOCKDB"."STOCK" ("SYMBOL") ON DELETE SET NULL NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."OWNS" ADD CONSTRAINT "FK_USER_OWNS_USERID" FOREIGN KEY ("USER_ID") REFERENCES "C##STOCKDB"."USER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table PARTICIPATION
-- ----------------------------
ALTER TABLE "C##STOCKDB"."PARTICIPATION" ADD CONSTRAINT "FK_PARTICIPATION_ACTIVITY_ID" FOREIGN KEY ("ACTIVITY_ID") REFERENCES "C##STOCKDB"."ACTIVITY" ("ACTIVITY_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;
ALTER TABLE "C##STOCKDB"."PARTICIPATION" ADD CONSTRAINT "FK_PARTICIPATION_USER_ID" FOREIGN KEY ("USER_ID") REFERENCES "C##STOCKDB"."USER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table PORTFOLIO
-- ----------------------------
ALTER TABLE "C##STOCKDB"."PORTFOLIO" ADD CONSTRAINT "FK_PORTFOLIO_USER_ID" FOREIGN KEY ("USER_ID") REFERENCES "C##STOCKDB"."CUSTOMER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table STOCK
-- ----------------------------
ALTER TABLE "C##STOCKDB"."STOCK" ADD CONSTRAINT "FK_STOCK_CORP_ID" FOREIGN KEY ("CORP_ID") REFERENCES "C##STOCKDB"."CORPORATION" ("CORP_ID") ON DELETE SET NULL NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table USER_CONTACT
-- ----------------------------
ALTER TABLE "C##STOCKDB"."USER_CONTACT" ADD CONSTRAINT "FK_USER_CONTACT_USER_ID" FOREIGN KEY ("USER_ID") REFERENCES "C##STOCKDB"."USER" ("USER_ID") ON DELETE CASCADE NOT DEFERRABLE INITIALLY IMMEDIATE NORELY VALIDATE;

-- ----------------------------
-- Foreign Keys structure for table USER_LOG
-- ----------------------------
